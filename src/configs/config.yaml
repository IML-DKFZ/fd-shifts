defaults:
  - hydra/job_logging: disabled
  - data: default_data.yaml

hydra:
  run:
    dir: ${exp.dir}
  output_subdir: hydra

exp:
  group_name: checks
  name: check_towards_confidnet #check_hydra_copy
  version: None
  mode: train_test   # train or test
  work_dir: ${hydra:runtime.cwd}
  fold_dir: exp/${exp.fold}
  root_dir: ${env:EXPERIMENT_ROOT_DIR}
  group_dir: ${env:EXPERIMENT_ROOT_DIR}/${exp.group_name}
  dir: ${exp.group_dir}/${exp.name}
  version_dir: ${exp.dir}/version_${exp.version}
  fold: 0 # call folds in launcher  via command line
  crossval_n_folds: 10
  crossval_ids_path: ${exp.dir}/crossval_ids.pickle
  raw_output_path: ${exp.version_dir}/raw_output.npy


test:
  name: test_results
  dir: ${exp.dir}/${test.name}
  cf_path: ${exp.dir}/hydra/config.yaml
  raw_output_path: ${test.dir}/raw_output.npy
  model_selection: best # latest or best

model:
  name: default_classifier
  n_filters: 32
  fc_dim: 512
  monitor_mcd_samples: 50 # only activated if "mcd" substring in train or val monitor confids.
  test_mcd_samples: 50 # only activated if "mcd" substring in test confids.
  backbone:
    name: small_conv
  callbacks: ["model_checkpoint",
              "confid_monitor" # not nice: model_checkpoint callback depends on confid_mointor callback
              ]

trainer:
  num_epochs: 100
  learning_rate: 1e-3
  momentum: 0.9
  weight_decay: 1e-4
  batch_size: 128
  num_classes: 10
  resume_from_ckpt: False
  save_top_k:
  selection_metric: val/accuracy     # in logging syntax: val/loss, makes ure to self.log() this metric! Set to empty to disable. also dont forget confid_prefix.
  selection_mode: max    # min:lower is better, max: higher is better
  benchmark: True # set to false if input size varies during training!
  global_seed: False # set to False to disable deterministic training.
  val_every_n_epoch: 1
  fast_dev_run: False # True/False/int


augmentations:
  train: # careful, the order here will determine the order of transforms (except normalize will be executed manually at the end after toTensor)
    normalize: [[0.5, 0.5, 0.5],[0.5, 0.5, 0.5]]
  val:
    normalize: [[0.5, 0.5, 0.5],[0.5, 0.5, 0.5]]
  test:
    normalize: [[0.5, 0.5, 0.5],[0.5, 0.5, 0.5]]

eval:
  performance_metrics:
    train: ['nll', 'accuracy'] # train brier_score logging costs around 5% performance
    val: ['nll', 'accuracy', 'brier_score']
    test: ['nll', 'accuracy', 'brier_score']
  confid_metrics:
    train: ['failauc', 'failap_suc', 'failap_err', "mce", "ece", "e-aurc", "aurc", "fpr@95tpr"]
    val: ['failauc', 'failap_suc', 'failap_err', "mce", "ece", "e-aurc", "aurc", "fpr@95tpr"]
    test: ['failauc', 'failap_suc', 'failap_err', "mce", "ece", "e-aurc", "aurc", "fpr@95tpr"]
  confidence_measures:
    train:
      [] # mcd_confs not available due to performance. 'det_mcp' costs around 3% (hard to say more volatile)
    val:
      ["det_mcp" , "det_pe", "mcd_mcp", "mcd_pe", "mcd_ee", "mcd_mi", "mcd_sv"]
    test:
      ["det_mcp" , "det_pe", "mcd_mcp", "mcd_pe", "mcd_ee", "mcd_mi", "mcd_sv"]

  monitor_plots: [ "calibration",
                   "overconfidence",
                   "hist_per_confid" ]

  tb_hparams: ['fold']
